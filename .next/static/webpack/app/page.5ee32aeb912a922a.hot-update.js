"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/assistant.ts":
/*!**************************!*\
  !*** ./lib/assistant.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   processMessages: () => (/* binding */ processMessages),\n/* harmony export */   stopGeneration: () => (/* binding */ stopGeneration)\n/* harmony export */ });\n/* harmony import */ var _config_functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/config/functions */ \"(app-pages-browser)/./config/functions.ts\");\n/* harmony import */ var _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/stores/useConversationStore */ \"(app-pages-browser)/./stores/useConversationStore.ts\");\n/* harmony import */ var _lib_tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/tools/tools */ \"(app-pages-browser)/./lib/tools/tools.ts\");\n\n\n\nlet controller = null;\nasync function processMessages(message) {\n    const { addChatMessage, addConversationItem, setAssistantLoading, conversationItems } = _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState();\n    // Add user message\n    const userMessage = {\n        type: \"message\",\n        role: \"user\",\n        content: [\n            {\n                type: \"input_text\",\n                text: message\n            }\n        ]\n    };\n    addChatMessage(userMessage);\n    addConversationItem(userMessage);\n    setAssistantLoading(true);\n    try {\n        const tools = await (0,_lib_tools_tools__WEBPACK_IMPORTED_MODULE_2__.getTools)();\n        const response = await fetch(\"/api/turn_response\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                messages: [\n                    ...conversationItems,\n                    userMessage\n                ],\n                tools\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        await handleTurn(response);\n    } catch (error) {\n        console.error(\"Error processing messages:\", error);\n        addChatMessage({\n            type: \"message\",\n            role: \"assistant\",\n            content: [\n                {\n                    type: \"output_text\",\n                    text: \"Sorry, I encountered an error. Please try again.\"\n                }\n            ]\n        });\n    } finally{\n        setAssistantLoading(false);\n    }\n}\nasync function handleTurn(response) {\n    var _response_body;\n    const { addChatMessage, addConversationItem } = _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState();\n    controller = new AbortController();\n    const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n    if (!reader) {\n        throw new Error(\"No response body reader available\");\n    }\n    const decoder = new TextDecoder();\n    let currentMessage = null;\n    let currentToolCalls = [];\n    let messageCreated = false;\n    try {\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) break;\n            const chunk = decoder.decode(value);\n            const lines = chunk.split('\\n').filter((line)=>line.trim() !== '');\n            for (const line of lines){\n                if (line.startsWith('data: ')) {\n                    try {\n                        const eventData = JSON.parse(line.slice(6));\n                        const result = await handleEvent(eventData, currentMessage, currentToolCalls, messageCreated);\n                        if (result) {\n                            currentMessage = result.message;\n                            messageCreated = result.messageCreated || messageCreated;\n                        }\n                    } catch (error) {\n                        console.error(\"Error parsing SSE data:\", error);\n                    }\n                }\n            }\n        }\n    } finally{\n        reader.releaseLock();\n        controller = null;\n    }\n}\nasync function handleEvent(eventData, currentMessage, currentToolCalls, messageCreated) {\n    const { addChatMessage, addConversationItem } = _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState();\n    switch(eventData.event){\n        case 'response.created':\n            // Response started, but don't create message yet\n            return null;\n        case 'response.output_item.added':\n            var _eventData_data_item;\n            // Only create message for actual message items, not reasoning\n            if (((_eventData_data_item = eventData.data.item) === null || _eventData_data_item === void 0 ? void 0 : _eventData_data_item.type) === 'message' && !messageCreated) {\n                currentMessage = {\n                    type: \"message\",\n                    role: \"assistant\",\n                    content: []\n                };\n                addChatMessage(currentMessage);\n                return {\n                    message: currentMessage,\n                    messageCreated: true\n                };\n            }\n            // Ignore reasoning items\n            return {\n                message: currentMessage,\n                messageCreated\n            };\n        case 'response.content_part.added':\n            // Only add content part if we have a message (not for reasoning)\n            if (currentMessage && eventData.data.item_id && eventData.data.output_index > 0) {\n                // Don't add another text part, it will be added when text starts streaming\n                return {\n                    message: currentMessage,\n                    messageCreated\n                };\n            }\n            return {\n                message: currentMessage,\n                messageCreated\n            };\n        case 'response.output_text.delta':\n            // Only process text deltas for actual messages (output_index > 0 means it's not reasoning)\n            if (currentMessage && eventData.data.output_index > 0 && eventData.data.delta) {\n                if (currentMessage.content.length === 0) {\n                    currentMessage.content.push({\n                        type: \"output_text\",\n                        text: \"\"\n                    });\n                }\n                const lastContent = currentMessage.content[currentMessage.content.length - 1];\n                if ((lastContent === null || lastContent === void 0 ? void 0 : lastContent.type) === 'output_text') {\n                    lastContent.text += eventData.data.delta;\n                    addChatMessage({\n                        ...currentMessage\n                    });\n                }\n            }\n            return {\n                message: currentMessage,\n                messageCreated\n            };\n        case 'response.function_call_delta':\n            // Handle function call streaming\n            const callId = eventData.data.id;\n            let toolCall = currentToolCalls.find((tc)=>tc.id === callId);\n            if (!toolCall) {\n                toolCall = {\n                    id: callId,\n                    type: 'function',\n                    function: {\n                        name: '',\n                        arguments: ''\n                    }\n                };\n                currentToolCalls.push(toolCall);\n                // Add tool call progress indicator\n                addChatMessage({\n                    type: \"tool_call_progress\",\n                    id: callId,\n                    name: eventData.data.name || '',\n                    status: \"executing\",\n                    progress: 0\n                });\n            }\n            if (eventData.data.name) {\n                toolCall.function.name = eventData.data.name;\n            }\n            if (eventData.data.arguments) {\n                toolCall.function.arguments += eventData.data.arguments;\n            }\n            return {\n                message: currentMessage,\n                messageCreated\n            };\n        case 'response.function_call_done':\n            // Execute the function call\n            const completedCall = currentToolCalls.find((tc)=>tc.id === eventData.data.id);\n            if (completedCall) {\n                await executeFunctionCall(completedCall);\n            }\n            return {\n                message: currentMessage,\n                messageCreated\n            };\n        case 'response.done':\n        case 'response.output_item.done':\n            var _eventData_data_item1, _eventData_data;\n            if (currentMessage && ((_eventData_data = eventData.data) === null || _eventData_data === void 0 ? void 0 : (_eventData_data_item1 = _eventData_data.item) === null || _eventData_data_item1 === void 0 ? void 0 : _eventData_data_item1.type) === 'message') {\n                addConversationItem(currentMessage);\n            }\n            return {\n                message: currentMessage,\n                messageCreated\n            };\n        default:\n            return {\n                message: currentMessage,\n                messageCreated\n            };\n    }\n}\nasync function executeFunctionCall(toolCall) {\n    const { addChatMessage } = _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState();\n    try {\n        // Update progress to show execution\n        addChatMessage({\n            type: \"tool_call_progress\",\n            id: toolCall.id,\n            name: toolCall.function.name,\n            status: \"executing\",\n            progress: 50\n        });\n        const functionName = toolCall.function.name;\n        const functionArgs = JSON.parse(toolCall.function.arguments);\n        if (_config_functions__WEBPACK_IMPORTED_MODULE_0__.functionsMap[functionName]) {\n            const result = await _config_functions__WEBPACK_IMPORTED_MODULE_0__.functionsMap[functionName](functionArgs);\n            // Update progress to show completion\n            addChatMessage({\n                type: \"tool_call_progress\",\n                id: toolCall.id,\n                name: toolCall.function.name,\n                status: \"completed\",\n                progress: 100,\n                result: result\n            });\n            // Add tool result to conversation\n            const toolResultMessage = {\n                type: \"message\",\n                role: \"tool\",\n                tool_call_id: toolCall.id,\n                content: [\n                    {\n                        type: \"tool_result\",\n                        result: JSON.stringify(result)\n                    }\n                ]\n            };\n            _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState().addConversationItem(toolResultMessage);\n            // Continue conversation with tool result\n            await processToolResult();\n        }\n    } catch (error) {\n        console.error(\"Error executing function call:\", error);\n        addChatMessage({\n            type: \"tool_call_progress\",\n            id: toolCall.id,\n            name: toolCall.function.name,\n            status: \"error\",\n            progress: 0,\n            error: error instanceof Error ? error.message : \"Unknown error\"\n        });\n    }\n}\nasync function processToolResult() {\n    const { conversationItems, setAssistantLoading } = _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState();\n    setAssistantLoading(true);\n    try {\n        const tools = await (0,_lib_tools_tools__WEBPACK_IMPORTED_MODULE_2__.getTools)();\n        const response = await fetch(\"/api/turn_response\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                messages: conversationItems,\n                tools\n            })\n        });\n        if (response.ok) {\n            await handleTurn(response);\n        }\n    } catch (error) {\n        console.error(\"Error processing tool result:\", error);\n    } finally{\n        setAssistantLoading(false);\n    }\n}\nfunction stopGeneration() {\n    if (controller) {\n        controller.abort();\n        controller = null;\n        _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState().setAssistantLoading(false);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WDtRQUNuQjtJQUNGLEVBQUUsT0FBT1ksT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsaUNBQWlDQTtJQUNqRCxTQUFVO1FBQ1JyQixvQkFBb0I7SUFDdEI7QUFDRjtBQUVPLFNBQVN5RTtJQUNkLElBQUk5RSxZQUFZO1FBQ2RBLFdBQVcrRSxLQUFLO1FBQ2hCL0UsYUFBYTtRQUNiRixvRUFBb0JBLENBQUNTLFFBQVEsR0FBR0YsbUJBQW1CLENBQUM7SUFDdEQ7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvYXNzaXN0YW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZ1bmN0aW9uc01hcCB9IGZyb20gXCJAL2NvbmZpZy9mdW5jdGlvbnNcIjtcbmltcG9ydCB1c2VDb252ZXJzYXRpb25TdG9yZSBmcm9tIFwiQC9zdG9yZXMvdXNlQ29udmVyc2F0aW9uU3RvcmVcIjtcbmltcG9ydCB7IGdldFRvb2xzIH0gZnJvbSBcIkAvbGliL3Rvb2xzL3Rvb2xzXCI7XG5cbmxldCBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIgfCBudWxsID0gbnVsbDtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlcyhtZXNzYWdlOiBzdHJpbmcpIHtcbiAgY29uc3QgeyBcbiAgICBhZGRDaGF0TWVzc2FnZSwgXG4gICAgYWRkQ29udmVyc2F0aW9uSXRlbSwgXG4gICAgc2V0QXNzaXN0YW50TG9hZGluZywgXG4gICAgY29udmVyc2F0aW9uSXRlbXMgXG4gIH0gPSB1c2VDb252ZXJzYXRpb25TdG9yZS5nZXRTdGF0ZSgpO1xuXG4gIC8vIEFkZCB1c2VyIG1lc3NhZ2VcbiAgY29uc3QgdXNlck1lc3NhZ2UgPSB7IFxuICAgIHR5cGU6IFwibWVzc2FnZVwiLCBcbiAgICByb2xlOiBcInVzZXJcIiwgXG4gICAgY29udGVudDogW3sgdHlwZTogXCJpbnB1dF90ZXh0XCIsIHRleHQ6IG1lc3NhZ2UgfV0gXG4gIH07XG4gIFxuICBhZGRDaGF0TWVzc2FnZSh1c2VyTWVzc2FnZSk7XG4gIGFkZENvbnZlcnNhdGlvbkl0ZW0odXNlck1lc3NhZ2UpO1xuXG4gIHNldEFzc2lzdGFudExvYWRpbmcodHJ1ZSk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB0b29scyA9IGF3YWl0IGdldFRvb2xzKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvdHVybl9yZXNwb25zZVwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBtZXNzYWdlczogWy4uLmNvbnZlcnNhdGlvbkl0ZW1zLCB1c2VyTWVzc2FnZV0sXG4gICAgICAgIHRvb2xzLFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuXG4gICAgYXdhaXQgaGFuZGxlVHVybihyZXNwb25zZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIHByb2Nlc3NpbmcgbWVzc2FnZXM6XCIsIGVycm9yKTtcbiAgICBhZGRDaGF0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBcIm1lc3NhZ2VcIixcbiAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsIFxuICAgICAgY29udGVudDogW3sgdHlwZTogXCJvdXRwdXRfdGV4dFwiLCB0ZXh0OiBcIlNvcnJ5LCBJIGVuY291bnRlcmVkIGFuIGVycm9yLiBQbGVhc2UgdHJ5IGFnYWluLlwiIH1dXG4gICAgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0QXNzaXN0YW50TG9hZGluZyhmYWxzZSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlVHVybihyZXNwb25zZTogUmVzcG9uc2UpIHtcbiAgY29uc3QgeyBhZGRDaGF0TWVzc2FnZSwgYWRkQ29udmVyc2F0aW9uSXRlbSB9ID0gdXNlQ29udmVyc2F0aW9uU3RvcmUuZ2V0U3RhdGUoKTtcbiAgXG4gIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHk/LmdldFJlYWRlcigpO1xuICBcbiAgaWYgKCFyZWFkZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXNwb25zZSBib2R5IHJlYWRlciBhdmFpbGFibGVcIik7XG4gIH1cblxuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGxldCBjdXJyZW50TWVzc2FnZTogYW55ID0gbnVsbDtcbiAgbGV0IGN1cnJlbnRUb29sQ2FsbHM6IGFueVtdID0gW107XG4gIGxldCBtZXNzYWdlQ3JlYXRlZCA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBcbiAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgIFxuICAgICAgY29uc3QgY2h1bmsgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSk7XG4gICAgICBjb25zdCBsaW5lcyA9IGNodW5rLnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSAhPT0gJycpO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnZGF0YTogJykpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnREYXRhID0gSlNPTi5wYXJzZShsaW5lLnNsaWNlKDYpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZUV2ZW50KGV2ZW50RGF0YSwgY3VycmVudE1lc3NhZ2UsIGN1cnJlbnRUb29sQ2FsbHMsIG1lc3NhZ2VDcmVhdGVkKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgY3VycmVudE1lc3NhZ2UgPSByZXN1bHQubWVzc2FnZTtcbiAgICAgICAgICAgICAgbWVzc2FnZUNyZWF0ZWQgPSByZXN1bHQubWVzc2FnZUNyZWF0ZWQgfHwgbWVzc2FnZUNyZWF0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwYXJzaW5nIFNTRSBkYXRhOlwiLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgIGNvbnRyb2xsZXIgPSBudWxsO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50RGF0YTogYW55LCBjdXJyZW50TWVzc2FnZTogYW55LCBjdXJyZW50VG9vbENhbGxzOiBhbnlbXSwgbWVzc2FnZUNyZWF0ZWQ6IGJvb2xlYW4pIHtcbiAgY29uc3QgeyBhZGRDaGF0TWVzc2FnZSwgYWRkQ29udmVyc2F0aW9uSXRlbSB9ID0gdXNlQ29udmVyc2F0aW9uU3RvcmUuZ2V0U3RhdGUoKTtcbiAgXG4gIHN3aXRjaCAoZXZlbnREYXRhLmV2ZW50KSB7XG4gICAgY2FzZSAncmVzcG9uc2UuY3JlYXRlZCc6XG4gICAgICAvLyBSZXNwb25zZSBzdGFydGVkLCBidXQgZG9uJ3QgY3JlYXRlIG1lc3NhZ2UgeWV0XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgJ3Jlc3BvbnNlLm91dHB1dF9pdGVtLmFkZGVkJzpcbiAgICAgIC8vIE9ubHkgY3JlYXRlIG1lc3NhZ2UgZm9yIGFjdHVhbCBtZXNzYWdlIGl0ZW1zLCBub3QgcmVhc29uaW5nXG4gICAgICBpZiAoZXZlbnREYXRhLmRhdGEuaXRlbT8udHlwZSA9PT0gJ21lc3NhZ2UnICYmICFtZXNzYWdlQ3JlYXRlZCkge1xuICAgICAgICBjdXJyZW50TWVzc2FnZSA9IHtcbiAgICAgICAgICB0eXBlOiBcIm1lc3NhZ2VcIixcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGFkZENoYXRNZXNzYWdlKGN1cnJlbnRNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3VycmVudE1lc3NhZ2UsIG1lc3NhZ2VDcmVhdGVkOiB0cnVlIH07XG4gICAgICB9XG4gICAgICAvLyBJZ25vcmUgcmVhc29uaW5nIGl0ZW1zXG4gICAgICByZXR1cm4geyBtZXNzYWdlOiBjdXJyZW50TWVzc2FnZSwgbWVzc2FnZUNyZWF0ZWQgfTtcblxuICAgIGNhc2UgJ3Jlc3BvbnNlLmNvbnRlbnRfcGFydC5hZGRlZCc6XG4gICAgICAvLyBPbmx5IGFkZCBjb250ZW50IHBhcnQgaWYgd2UgaGF2ZSBhIG1lc3NhZ2UgKG5vdCBmb3IgcmVhc29uaW5nKVxuICAgICAgaWYgKGN1cnJlbnRNZXNzYWdlICYmIGV2ZW50RGF0YS5kYXRhLml0ZW1faWQgJiYgZXZlbnREYXRhLmRhdGEub3V0cHV0X2luZGV4ID4gMCkge1xuICAgICAgICAvLyBEb24ndCBhZGQgYW5vdGhlciB0ZXh0IHBhcnQsIGl0IHdpbGwgYmUgYWRkZWQgd2hlbiB0ZXh0IHN0YXJ0cyBzdHJlYW1pbmdcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3VycmVudE1lc3NhZ2UsIG1lc3NhZ2VDcmVhdGVkIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBtZXNzYWdlOiBjdXJyZW50TWVzc2FnZSwgbWVzc2FnZUNyZWF0ZWQgfTtcblxuICAgIGNhc2UgJ3Jlc3BvbnNlLm91dHB1dF90ZXh0LmRlbHRhJzpcbiAgICAgIC8vIE9ubHkgcHJvY2VzcyB0ZXh0IGRlbHRhcyBmb3IgYWN0dWFsIG1lc3NhZ2VzIChvdXRwdXRfaW5kZXggPiAwIG1lYW5zIGl0J3Mgbm90IHJlYXNvbmluZylcbiAgICAgIGlmIChjdXJyZW50TWVzc2FnZSAmJiBldmVudERhdGEuZGF0YS5vdXRwdXRfaW5kZXggPiAwICYmIGV2ZW50RGF0YS5kYXRhLmRlbHRhKSB7XG4gICAgICAgIGlmIChjdXJyZW50TWVzc2FnZS5jb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRNZXNzYWdlLmNvbnRlbnQucHVzaCh7IHR5cGU6IFwib3V0cHV0X3RleHRcIiwgdGV4dDogXCJcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0Q29udGVudCA9IGN1cnJlbnRNZXNzYWdlLmNvbnRlbnRbY3VycmVudE1lc3NhZ2UuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RDb250ZW50Py50eXBlID09PSAnb3V0cHV0X3RleHQnKSB7XG4gICAgICAgICAgbGFzdENvbnRlbnQudGV4dCArPSBldmVudERhdGEuZGF0YS5kZWx0YTtcbiAgICAgICAgICBhZGRDaGF0TWVzc2FnZSh7IC4uLmN1cnJlbnRNZXNzYWdlIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBtZXNzYWdlOiBjdXJyZW50TWVzc2FnZSwgbWVzc2FnZUNyZWF0ZWQgfTtcblxuICAgIGNhc2UgJ3Jlc3BvbnNlLmZ1bmN0aW9uX2NhbGxfZGVsdGEnOlxuICAgICAgLy8gSGFuZGxlIGZ1bmN0aW9uIGNhbGwgc3RyZWFtaW5nXG4gICAgICBjb25zdCBjYWxsSWQgPSBldmVudERhdGEuZGF0YS5pZDtcbiAgICAgIGxldCB0b29sQ2FsbCA9IGN1cnJlbnRUb29sQ2FsbHMuZmluZCh0YyA9PiB0Yy5pZCA9PT0gY2FsbElkKTtcbiAgICAgIFxuICAgICAgaWYgKCF0b29sQ2FsbCkge1xuICAgICAgICB0b29sQ2FsbCA9IHtcbiAgICAgICAgICBpZDogY2FsbElkLFxuICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgZnVuY3Rpb246IHsgbmFtZTogJycsIGFyZ3VtZW50czogJycgfVxuICAgICAgICB9O1xuICAgICAgICBjdXJyZW50VG9vbENhbGxzLnB1c2godG9vbENhbGwpO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHRvb2wgY2FsbCBwcm9ncmVzcyBpbmRpY2F0b3JcbiAgICAgICAgYWRkQ2hhdE1lc3NhZ2Uoe1xuICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsX3Byb2dyZXNzXCIsXG4gICAgICAgICAgaWQ6IGNhbGxJZCxcbiAgICAgICAgICBuYW1lOiBldmVudERhdGEuZGF0YS5uYW1lIHx8ICcnLFxuICAgICAgICAgIHN0YXR1czogXCJleGVjdXRpbmdcIixcbiAgICAgICAgICBwcm9ncmVzczogMFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50RGF0YS5kYXRhLm5hbWUpIHtcbiAgICAgICAgdG9vbENhbGwuZnVuY3Rpb24ubmFtZSA9IGV2ZW50RGF0YS5kYXRhLm5hbWU7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnREYXRhLmRhdGEuYXJndW1lbnRzKSB7XG4gICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyArPSBldmVudERhdGEuZGF0YS5hcmd1bWVudHM7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBtZXNzYWdlOiBjdXJyZW50TWVzc2FnZSwgbWVzc2FnZUNyZWF0ZWQgfTtcblxuICAgIGNhc2UgJ3Jlc3BvbnNlLmZ1bmN0aW9uX2NhbGxfZG9uZSc6XG4gICAgICAvLyBFeGVjdXRlIHRoZSBmdW5jdGlvbiBjYWxsXG4gICAgICBjb25zdCBjb21wbGV0ZWRDYWxsID0gY3VycmVudFRvb2xDYWxscy5maW5kKHRjID0+IHRjLmlkID09PSBldmVudERhdGEuZGF0YS5pZCk7XG4gICAgICBpZiAoY29tcGxldGVkQ2FsbCkge1xuICAgICAgICBhd2FpdCBleGVjdXRlRnVuY3Rpb25DYWxsKGNvbXBsZXRlZENhbGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3VycmVudE1lc3NhZ2UsIG1lc3NhZ2VDcmVhdGVkIH07XG5cbiAgICBjYXNlICdyZXNwb25zZS5kb25lJzpcbiAgICBjYXNlICdyZXNwb25zZS5vdXRwdXRfaXRlbS5kb25lJzpcbiAgICAgIGlmIChjdXJyZW50TWVzc2FnZSAmJiBldmVudERhdGEuZGF0YT8uaXRlbT8udHlwZSA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICAgIGFkZENvbnZlcnNhdGlvbkl0ZW0oY3VycmVudE1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3VycmVudE1lc3NhZ2UsIG1lc3NhZ2VDcmVhdGVkIH07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3VycmVudE1lc3NhZ2UsIG1lc3NhZ2VDcmVhdGVkIH07XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUZ1bmN0aW9uQ2FsbCh0b29sQ2FsbDogYW55KSB7XG4gIGNvbnN0IHsgYWRkQ2hhdE1lc3NhZ2UgfSA9IHVzZUNvbnZlcnNhdGlvblN0b3JlLmdldFN0YXRlKCk7XG4gIFxuICB0cnkge1xuICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyB0byBzaG93IGV4ZWN1dGlvblxuICAgIGFkZENoYXRNZXNzYWdlKHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsX3Byb2dyZXNzXCIsXG4gICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICBuYW1lOiB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgc3RhdHVzOiBcImV4ZWN1dGluZ1wiLCBcbiAgICAgIHByb2dyZXNzOiA1MFxuICAgIH0pO1xuXG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gdG9vbENhbGwuZnVuY3Rpb24ubmFtZTtcbiAgICBjb25zdCBmdW5jdGlvbkFyZ3MgPSBKU09OLnBhcnNlKHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyk7XG4gICAgXG4gICAgaWYgKGZ1bmN0aW9uc01hcFtmdW5jdGlvbk5hbWUgYXMga2V5b2YgdHlwZW9mIGZ1bmN0aW9uc01hcF0pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZ1bmN0aW9uc01hcFtmdW5jdGlvbk5hbWUgYXMga2V5b2YgdHlwZW9mIGZ1bmN0aW9uc01hcF0oZnVuY3Rpb25BcmdzKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHByb2dyZXNzIHRvIHNob3cgY29tcGxldGlvblxuICAgICAgYWRkQ2hhdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcInRvb2xfY2FsbF9wcm9ncmVzc1wiLFxuICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgIG5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgIHN0YXR1czogXCJjb21wbGV0ZWRcIixcbiAgICAgICAgcHJvZ3Jlc3M6IDEwMCxcbiAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGQgdG9vbCByZXN1bHQgdG8gY29udmVyc2F0aW9uXG4gICAgICBjb25zdCB0b29sUmVzdWx0TWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZTogXCJtZXNzYWdlXCIsXG4gICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICB0b29sX2NhbGxfaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRvb2xfcmVzdWx0XCIsIHJlc3VsdDogSlNPTi5zdHJpbmdpZnkocmVzdWx0KSB9XVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgdXNlQ29udmVyc2F0aW9uU3RvcmUuZ2V0U3RhdGUoKS5hZGRDb252ZXJzYXRpb25JdGVtKHRvb2xSZXN1bHRNZXNzYWdlKTtcbiAgICAgIFxuICAgICAgLy8gQ29udGludWUgY29udmVyc2F0aW9uIHdpdGggdG9vbCByZXN1bHRcbiAgICAgIGF3YWl0IHByb2Nlc3NUb29sUmVzdWx0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBleGVjdXRpbmcgZnVuY3Rpb24gY2FsbDpcIiwgZXJyb3IpO1xuICAgIGFkZENoYXRNZXNzYWdlKHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsX3Byb2dyZXNzXCIsXG4gICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICBuYW1lOiB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgc3RhdHVzOiBcImVycm9yXCIsXG4gICAgICBwcm9ncmVzczogMCxcbiAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiXG4gICAgfSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1Rvb2xSZXN1bHQoKSB7XG4gIGNvbnN0IHsgY29udmVyc2F0aW9uSXRlbXMsIHNldEFzc2lzdGFudExvYWRpbmcgfSA9IHVzZUNvbnZlcnNhdGlvblN0b3JlLmdldFN0YXRlKCk7XG4gIFxuICBzZXRBc3Npc3RhbnRMb2FkaW5nKHRydWUpO1xuICBcbiAgdHJ5IHtcbiAgICBjb25zdCB0b29scyA9IGF3YWl0IGdldFRvb2xzKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvdHVybl9yZXNwb25zZVwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBtZXNzYWdlczogY29udmVyc2F0aW9uSXRlbXMsXG4gICAgICAgIHRvb2xzLFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGF3YWl0IGhhbmRsZVR1cm4ocmVzcG9uc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcHJvY2Vzc2luZyB0b29sIHJlc3VsdDpcIiwgZXJyb3IpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldEFzc2lzdGFudExvYWRpbmcoZmFsc2UpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdG9wR2VuZXJhdGlvbigpIHtcbiAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgY29udHJvbGxlciA9IG51bGw7XG4gICAgdXNlQ29udmVyc2F0aW9uU3RvcmUuZ2V0U3RhdGUoKS5zZXRBc3Npc3RhbnRMb2FkaW5nKGZhbHNlKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImZ1bmN0aW9uc01hcCIsInVzZUNvbnZlcnNhdGlvblN0b3JlIiwiZ2V0VG9vbHMiLCJjb250cm9sbGVyIiwicHJvY2Vzc01lc3NhZ2VzIiwibWVzc2FnZSIsImFkZENoYXRNZXNzYWdlIiwiYWRkQ29udmVyc2F0aW9uSXRlbSIsInNldEFzc2lzdGFudExvYWRpbmciLCJjb252ZXJzYXRpb25JdGVtcyIsImdldFN0YXRlIiwidXNlck1lc3NhZ2UiLCJ0eXBlIiwicm9sZSIsImNvbnRlbnQiLCJ0ZXh0IiwidG9vbHMiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwibWVzc2FnZXMiLCJvayIsIkVycm9yIiwic3RhdHVzIiwiaGFuZGxlVHVybiIsImVycm9yIiwiY29uc29sZSIsIkFib3J0Q29udHJvbGxlciIsInJlYWRlciIsImdldFJlYWRlciIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImN1cnJlbnRNZXNzYWdlIiwiY3VycmVudFRvb2xDYWxscyIsIm1lc3NhZ2VDcmVhdGVkIiwiZG9uZSIsInZhbHVlIiwicmVhZCIsImNodW5rIiwiZGVjb2RlIiwibGluZXMiLCJzcGxpdCIsImZpbHRlciIsImxpbmUiLCJ0cmltIiwic3RhcnRzV2l0aCIsImV2ZW50RGF0YSIsInBhcnNlIiwic2xpY2UiLCJyZXN1bHQiLCJoYW5kbGVFdmVudCIsInJlbGVhc2VMb2NrIiwiZXZlbnQiLCJkYXRhIiwiaXRlbSIsIml0ZW1faWQiLCJvdXRwdXRfaW5kZXgiLCJkZWx0YSIsImxlbmd0aCIsInB1c2giLCJsYXN0Q29udGVudCIsImNhbGxJZCIsImlkIiwidG9vbENhbGwiLCJmaW5kIiwidGMiLCJmdW5jdGlvbiIsIm5hbWUiLCJhcmd1bWVudHMiLCJwcm9ncmVzcyIsImNvbXBsZXRlZENhbGwiLCJleGVjdXRlRnVuY3Rpb25DYWxsIiwiZnVuY3Rpb25OYW1lIiwiZnVuY3Rpb25BcmdzIiwidG9vbFJlc3VsdE1lc3NhZ2UiLCJ0b29sX2NhbGxfaWQiLCJwcm9jZXNzVG9vbFJlc3VsdCIsInN0b3BHZW5lcmF0aW9uIiwiYWJvcnQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/assistant.ts\n"));

/***/ })

});