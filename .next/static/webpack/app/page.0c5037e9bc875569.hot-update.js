"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/assistant.ts":
/*!**************************!*\
  !*** ./lib/assistant.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   processMessages: () => (/* binding */ processMessages),\n/* harmony export */   stopGeneration: () => (/* binding */ stopGeneration)\n/* harmony export */ });\n/* harmony import */ var _config_functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/config/functions */ \"(app-pages-browser)/./config/functions.ts\");\n/* harmony import */ var _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/stores/useConversationStore */ \"(app-pages-browser)/./stores/useConversationStore.ts\");\n/* harmony import */ var _lib_tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/tools/tools */ \"(app-pages-browser)/./lib/tools/tools.ts\");\n\n\n\nlet controller = null;\nasync function processMessages(message) {\n    const { addChatMessage, addConversationItem, setAssistantLoading, conversationItems } = _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState();\n    // Add user message\n    const userMessage = {\n        type: \"message\",\n        role: \"user\",\n        content: [\n            {\n                type: \"input_text\",\n                text: message\n            }\n        ]\n    };\n    addChatMessage(userMessage);\n    addConversationItem(userMessage);\n    setAssistantLoading(true);\n    try {\n        const tools = await (0,_lib_tools_tools__WEBPACK_IMPORTED_MODULE_2__.getTools)();\n        const response = await fetch(\"/api/turn_response\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                messages: [\n                    ...conversationItems,\n                    userMessage\n                ],\n                tools\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        await handleTurn(response);\n    } catch (error) {\n        console.error(\"Error processing messages:\", error);\n        addChatMessage({\n            type: \"message\",\n            role: \"assistant\",\n            content: [\n                {\n                    type: \"output_text\",\n                    text: \"Sorry, I encountered an error. Please try again.\"\n                }\n            ]\n        });\n    } finally{\n        setAssistantLoading(false);\n    }\n}\nasync function handleTurn(response) {\n    var _response_body;\n    const { addChatMessage, addConversationItem } = _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState();\n    controller = new AbortController();\n    const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n    if (!reader) {\n        throw new Error(\"No response body reader available\");\n    }\n    const decoder = new TextDecoder();\n    let currentMessage = null;\n    let currentToolCalls = [];\n    try {\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) break;\n            const chunk = decoder.decode(value);\n            const lines = chunk.split('\\n').filter((line)=>line.trim() !== '');\n            for (const line of lines){\n                if (line.startsWith('data: ')) {\n                    try {\n                        const eventData = JSON.parse(line.slice(6));\n                        await handleEvent(eventData, currentMessage, currentToolCalls);\n                    } catch (error) {\n                        console.error(\"Error parsing SSE data:\", error);\n                    }\n                }\n            }\n        }\n    } finally{\n        reader.releaseLock();\n        controller = null;\n    }\n}\nasync function handleEvent(eventData, currentMessage, currentToolCalls) {\n    const { addChatMessage, addConversationItem } = _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState();\n    switch(eventData.event){\n        case 'response.created':\n            currentMessage = {\n                type: \"message\",\n                role: \"assistant\",\n                content: []\n            };\n            addChatMessage(currentMessage);\n            break;\n        case 'response.output_item.added':\n            var _eventData_data_item;\n            // New text output item added\n            if (((_eventData_data_item = eventData.data.item) === null || _eventData_data_item === void 0 ? void 0 : _eventData_data_item.type) === 'message') {\n                const textPart = {\n                    type: \"output_text\",\n                    text: \"\"\n                };\n                currentMessage.content.push(textPart);\n                addChatMessage({\n                    ...currentMessage\n                });\n            }\n            break;\n        case 'response.content_part.added':\n            // Text content part added\n            const textPart = {\n                type: \"output_text\",\n                text: \"\"\n            };\n            currentMessage.content.push(textPart);\n            addChatMessage({\n                ...currentMessage\n            });\n            break;\n        case 'response.output_text.delta':\n            // Text delta for streaming\n            if (eventData.data.delta) {\n                if (currentMessage.content.length === 0) {\n                    currentMessage.content.push({\n                        type: \"output_text\",\n                        text: \"\"\n                    });\n                }\n                const lastContent = currentMessage.content[currentMessage.content.length - 1];\n                if ((lastContent === null || lastContent === void 0 ? void 0 : lastContent.type) === 'output_text') {\n                    lastContent.text += eventData.data.delta;\n                    addChatMessage({\n                        ...currentMessage\n                    });\n                }\n            }\n            break;\n        case 'response.function_call_delta':\n            // Handle function call streaming\n            const callId = eventData.data.id;\n            let toolCall = currentToolCalls.find((tc)=>tc.id === callId);\n            if (!toolCall) {\n                toolCall = {\n                    id: callId,\n                    type: 'function',\n                    function: {\n                        name: '',\n                        arguments: ''\n                    }\n                };\n                currentToolCalls.push(toolCall);\n                // Add tool call progress indicator\n                addChatMessage({\n                    type: \"tool_call_progress\",\n                    id: callId,\n                    name: eventData.data.name || '',\n                    status: \"executing\",\n                    progress: 0\n                });\n            }\n            if (eventData.data.name) {\n                toolCall.function.name = eventData.data.name;\n            }\n            if (eventData.data.arguments) {\n                toolCall.function.arguments += eventData.data.arguments;\n            }\n            break;\n        case 'response.function_call_done':\n            // Execute the function call\n            const completedCall = currentToolCalls.find((tc)=>tc.id === eventData.data.id);\n            if (completedCall) {\n                await executeFunctionCall(completedCall);\n            }\n            break;\n        case 'response.done':\n            if (currentMessage) {\n                addConversationItem(currentMessage);\n            }\n            break;\n    }\n}\nasync function executeFunctionCall(toolCall) {\n    const { addChatMessage } = _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState();\n    try {\n        // Update progress to show execution\n        addChatMessage({\n            type: \"tool_call_progress\",\n            id: toolCall.id,\n            name: toolCall.function.name,\n            status: \"executing\",\n            progress: 50\n        });\n        const functionName = toolCall.function.name;\n        const functionArgs = JSON.parse(toolCall.function.arguments);\n        if (_config_functions__WEBPACK_IMPORTED_MODULE_0__.functionsMap[functionName]) {\n            const result = await _config_functions__WEBPACK_IMPORTED_MODULE_0__.functionsMap[functionName](functionArgs);\n            // Update progress to show completion\n            addChatMessage({\n                type: \"tool_call_progress\",\n                id: toolCall.id,\n                name: toolCall.function.name,\n                status: \"completed\",\n                progress: 100,\n                result: result\n            });\n            // Add tool result to conversation\n            const toolResultMessage = {\n                type: \"message\",\n                role: \"tool\",\n                tool_call_id: toolCall.id,\n                content: [\n                    {\n                        type: \"tool_result\",\n                        result: JSON.stringify(result)\n                    }\n                ]\n            };\n            _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState().addConversationItem(toolResultMessage);\n            // Continue conversation with tool result\n            await processToolResult();\n        }\n    } catch (error) {\n        console.error(\"Error executing function call:\", error);\n        addChatMessage({\n            type: \"tool_call_progress\",\n            id: toolCall.id,\n            name: toolCall.function.name,\n            status: \"error\",\n            progress: 0,\n            error: error instanceof Error ? error.message : \"Unknown error\"\n        });\n    }\n}\nasync function processToolResult() {\n    const { conversationItems, setAssistantLoading } = _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState();\n    setAssistantLoading(true);\n    try {\n        const tools = await (0,_lib_tools_tools__WEBPACK_IMPORTED_MODULE_2__.getTools)();\n        const response = await fetch(\"/api/turn_response\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                messages: conversationItems,\n                tools\n            })\n        });\n        if (response.ok) {\n            await handleTurn(response);\n        }\n    } catch (error) {\n        console.error(\"Error processing tool result:\", error);\n    } finally{\n        setAssistantLoading(false);\n    }\n}\nfunction stopGeneration() {\n    if (controller) {\n        controller.abort();\n        controller = null;\n        _stores_useConversationStore__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getState().setAssistantLoading(false);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0EsaUJBQWlCSCxRQUFRRyxNQUFNeEIsT0FBTyxHQUFHO1FBQ2xEO0lBQ0Y7QUFDRjtBQUVBLGVBQWV5RTtJQUNiLE1BQU0sRUFBRXJFLGlCQUFpQixFQUFFRCxtQkFBbUIsRUFBRSxHQUFHUCxvRUFBb0JBLENBQUNTLFFBQVE7SUFFaEZGLG9CQUFvQjtJQUVwQixJQUFJO1FBQ0YsTUFBTVEsUUFBUSxNQUFNZCwwREFBUUE7UUFDNUIsTUFBTWUsV0FBVyxNQUFNQyxNQUFNLHNCQUFzQjtZQUNqREMsUUFBUTtZQUNSQyxTQUFTO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO2dCQUNuQkMsVUFBVWY7Z0JBQ1ZPO1lBQ0Y7UUFDRjtRQUVBLElBQUlDLFNBQVNRLEVBQUUsRUFBRTtZQUNmLE1BQU1HLFdBQVdYO1FBQ25CO0lBQ0YsRUFBRSxPQUFPWSxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNBO0lBQ2pELFNBQVU7UUFDUnJCLG9CQUFvQjtJQUN0QjtBQUNGO0FBRU8sU0FBU3VFO0lBQ2QsSUFBSTVFLFlBQVk7UUFDZEEsV0FBVzZFLEtBQUs7UUFDaEI3RSxhQUFhO1FBQ2JGLG9FQUFvQkEsQ0FBQ1MsUUFBUSxHQUFHRixtQkFBbUIsQ0FBQztJQUN0RDtBQUNGIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL2xpYi9hc3Npc3RhbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZnVuY3Rpb25zTWFwIH0gZnJvbSBcIkAvY29uZmlnL2Z1bmN0aW9uc1wiO1xuaW1wb3J0IHVzZUNvbnZlcnNhdGlvblN0b3JlIGZyb20gXCJAL3N0b3Jlcy91c2VDb252ZXJzYXRpb25TdG9yZVwiO1xuaW1wb3J0IHsgZ2V0VG9vbHMgfSBmcm9tIFwiQC9saWIvdG9vbHMvdG9vbHNcIjtcblxubGV0IGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlciB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc01lc3NhZ2VzKG1lc3NhZ2U6IHN0cmluZykge1xuICBjb25zdCB7IFxuICAgIGFkZENoYXRNZXNzYWdlLCBcbiAgICBhZGRDb252ZXJzYXRpb25JdGVtLCBcbiAgICBzZXRBc3Npc3RhbnRMb2FkaW5nLCBcbiAgICBjb252ZXJzYXRpb25JdGVtcyBcbiAgfSA9IHVzZUNvbnZlcnNhdGlvblN0b3JlLmdldFN0YXRlKCk7XG5cbiAgLy8gQWRkIHVzZXIgbWVzc2FnZVxuICBjb25zdCB1c2VyTWVzc2FnZSA9IHsgXG4gICAgdHlwZTogXCJtZXNzYWdlXCIsIFxuICAgIHJvbGU6IFwidXNlclwiLCBcbiAgICBjb250ZW50OiBbeyB0eXBlOiBcImlucHV0X3RleHRcIiwgdGV4dDogbWVzc2FnZSB9XSBcbiAgfTtcbiAgXG4gIGFkZENoYXRNZXNzYWdlKHVzZXJNZXNzYWdlKTtcbiAgYWRkQ29udmVyc2F0aW9uSXRlbSh1c2VyTWVzc2FnZSk7XG5cbiAgc2V0QXNzaXN0YW50TG9hZGluZyh0cnVlKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHRvb2xzID0gYXdhaXQgZ2V0VG9vbHMoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiL2FwaS90dXJuX3Jlc3BvbnNlXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG1lc3NhZ2VzOiBbLi4uY29udmVyc2F0aW9uSXRlbXMsIHVzZXJNZXNzYWdlXSxcbiAgICAgICAgdG9vbHMsXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBhd2FpdCBoYW5kbGVUdXJuKHJlc3BvbnNlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcHJvY2Vzc2luZyBtZXNzYWdlczpcIiwgZXJyb3IpO1xuICAgIGFkZENoYXRNZXNzYWdlKHtcbiAgICAgIHR5cGU6IFwibWVzc2FnZVwiLFxuICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIiwgXG4gICAgICBjb250ZW50OiBbeyB0eXBlOiBcIm91dHB1dF90ZXh0XCIsIHRleHQ6IFwiU29ycnksIEkgZW5jb3VudGVyZWQgYW4gZXJyb3IuIFBsZWFzZSB0cnkgYWdhaW4uXCIgfV1cbiAgICB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRBc3Npc3RhbnRMb2FkaW5nKGZhbHNlKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVUdXJuKHJlc3BvbnNlOiBSZXNwb25zZSkge1xuICBjb25zdCB7IGFkZENoYXRNZXNzYWdlLCBhZGRDb252ZXJzYXRpb25JdGVtIH0gPSB1c2VDb252ZXJzYXRpb25TdG9yZS5nZXRTdGF0ZSgpO1xuICBcbiAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keT8uZ2V0UmVhZGVyKCk7XG4gIFxuICBpZiAoIXJlYWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlc3BvbnNlIGJvZHkgcmVhZGVyIGF2YWlsYWJsZVwiKTtcbiAgfVxuXG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgbGV0IGN1cnJlbnRNZXNzYWdlOiBhbnkgPSBudWxsO1xuICBsZXQgY3VycmVudFRvb2xDYWxsczogYW55W10gPSBbXTtcblxuICB0cnkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgXG4gICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICBcbiAgICAgIGNvbnN0IGNodW5rID0gZGVjb2Rlci5kZWNvZGUodmFsdWUpO1xuICAgICAgY29uc3QgbGluZXMgPSBjaHVuay5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkgIT09ICcnKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ2RhdGE6ICcpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IEpTT04ucGFyc2UobGluZS5zbGljZSg2KSk7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVFdmVudChldmVudERhdGEsIGN1cnJlbnRNZXNzYWdlLCBjdXJyZW50VG9vbENhbGxzKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHBhcnNpbmcgU1NFIGRhdGE6XCIsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgY29udHJvbGxlciA9IG51bGw7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnREYXRhOiBhbnksIGN1cnJlbnRNZXNzYWdlOiBhbnksIGN1cnJlbnRUb29sQ2FsbHM6IGFueVtdKSB7XG4gIGNvbnN0IHsgYWRkQ2hhdE1lc3NhZ2UsIGFkZENvbnZlcnNhdGlvbkl0ZW0gfSA9IHVzZUNvbnZlcnNhdGlvblN0b3JlLmdldFN0YXRlKCk7XG4gIFxuICBzd2l0Y2ggKGV2ZW50RGF0YS5ldmVudCkge1xuICAgIGNhc2UgJ3Jlc3BvbnNlLmNyZWF0ZWQnOlxuICAgICAgY3VycmVudE1lc3NhZ2UgPSB7XG4gICAgICAgIHR5cGU6IFwibWVzc2FnZVwiLFxuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBbXVxuICAgICAgfTtcbiAgICAgIGFkZENoYXRNZXNzYWdlKGN1cnJlbnRNZXNzYWdlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmVzcG9uc2Uub3V0cHV0X2l0ZW0uYWRkZWQnOlxuICAgICAgLy8gTmV3IHRleHQgb3V0cHV0IGl0ZW0gYWRkZWRcbiAgICAgIGlmIChldmVudERhdGEuZGF0YS5pdGVtPy50eXBlID09PSAnbWVzc2FnZScpIHtcbiAgICAgICAgY29uc3QgdGV4dFBhcnQgPSB7IHR5cGU6IFwib3V0cHV0X3RleHRcIiwgdGV4dDogXCJcIiB9O1xuICAgICAgICBjdXJyZW50TWVzc2FnZS5jb250ZW50LnB1c2godGV4dFBhcnQpO1xuICAgICAgICBhZGRDaGF0TWVzc2FnZSh7IC4uLmN1cnJlbnRNZXNzYWdlIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyZXNwb25zZS5jb250ZW50X3BhcnQuYWRkZWQnOlxuICAgICAgLy8gVGV4dCBjb250ZW50IHBhcnQgYWRkZWRcbiAgICAgIGNvbnN0IHRleHRQYXJ0ID0geyB0eXBlOiBcIm91dHB1dF90ZXh0XCIsIHRleHQ6IFwiXCIgfTtcbiAgICAgIGN1cnJlbnRNZXNzYWdlLmNvbnRlbnQucHVzaCh0ZXh0UGFydCk7XG4gICAgICBhZGRDaGF0TWVzc2FnZSh7IC4uLmN1cnJlbnRNZXNzYWdlIH0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyZXNwb25zZS5vdXRwdXRfdGV4dC5kZWx0YSc6XG4gICAgICAvLyBUZXh0IGRlbHRhIGZvciBzdHJlYW1pbmdcbiAgICAgIGlmIChldmVudERhdGEuZGF0YS5kZWx0YSkge1xuICAgICAgICBpZiAoY3VycmVudE1lc3NhZ2UuY29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjdXJyZW50TWVzc2FnZS5jb250ZW50LnB1c2goeyB0eXBlOiBcIm91dHB1dF90ZXh0XCIsIHRleHQ6IFwiXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdENvbnRlbnQgPSBjdXJyZW50TWVzc2FnZS5jb250ZW50W2N1cnJlbnRNZXNzYWdlLmNvbnRlbnQubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0Q29udGVudD8udHlwZSA9PT0gJ291dHB1dF90ZXh0Jykge1xuICAgICAgICAgIGxhc3RDb250ZW50LnRleHQgKz0gZXZlbnREYXRhLmRhdGEuZGVsdGE7XG4gICAgICAgICAgYWRkQ2hhdE1lc3NhZ2UoeyAuLi5jdXJyZW50TWVzc2FnZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyZXNwb25zZS5mdW5jdGlvbl9jYWxsX2RlbHRhJzpcbiAgICAgIC8vIEhhbmRsZSBmdW5jdGlvbiBjYWxsIHN0cmVhbWluZ1xuICAgICAgY29uc3QgY2FsbElkID0gZXZlbnREYXRhLmRhdGEuaWQ7XG4gICAgICBsZXQgdG9vbENhbGwgPSBjdXJyZW50VG9vbENhbGxzLmZpbmQodGMgPT4gdGMuaWQgPT09IGNhbGxJZCk7XG4gICAgICBcbiAgICAgIGlmICghdG9vbENhbGwpIHtcbiAgICAgICAgdG9vbENhbGwgPSB7XG4gICAgICAgICAgaWQ6IGNhbGxJZCxcbiAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgIGZ1bmN0aW9uOiB7IG5hbWU6ICcnLCBhcmd1bWVudHM6ICcnIH1cbiAgICAgICAgfTtcbiAgICAgICAgY3VycmVudFRvb2xDYWxscy5wdXNoKHRvb2xDYWxsKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCB0b29sIGNhbGwgcHJvZ3Jlc3MgaW5kaWNhdG9yXG4gICAgICAgIGFkZENoYXRNZXNzYWdlKHtcbiAgICAgICAgICB0eXBlOiBcInRvb2xfY2FsbF9wcm9ncmVzc1wiLFxuICAgICAgICAgIGlkOiBjYWxsSWQsXG4gICAgICAgICAgbmFtZTogZXZlbnREYXRhLmRhdGEubmFtZSB8fCAnJyxcbiAgICAgICAgICBzdGF0dXM6IFwiZXhlY3V0aW5nXCIsXG4gICAgICAgICAgcHJvZ3Jlc3M6IDBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudERhdGEuZGF0YS5uYW1lKSB7XG4gICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUgPSBldmVudERhdGEuZGF0YS5uYW1lO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50RGF0YS5kYXRhLmFyZ3VtZW50cykge1xuICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgKz0gZXZlbnREYXRhLmRhdGEuYXJndW1lbnRzO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyZXNwb25zZS5mdW5jdGlvbl9jYWxsX2RvbmUnOlxuICAgICAgLy8gRXhlY3V0ZSB0aGUgZnVuY3Rpb24gY2FsbFxuICAgICAgY29uc3QgY29tcGxldGVkQ2FsbCA9IGN1cnJlbnRUb29sQ2FsbHMuZmluZCh0YyA9PiB0Yy5pZCA9PT0gZXZlbnREYXRhLmRhdGEuaWQpO1xuICAgICAgaWYgKGNvbXBsZXRlZENhbGwpIHtcbiAgICAgICAgYXdhaXQgZXhlY3V0ZUZ1bmN0aW9uQ2FsbChjb21wbGV0ZWRDYWxsKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmVzcG9uc2UuZG9uZSc6XG4gICAgICBpZiAoY3VycmVudE1lc3NhZ2UpIHtcbiAgICAgICAgYWRkQ29udmVyc2F0aW9uSXRlbShjdXJyZW50TWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBleGVjdXRlRnVuY3Rpb25DYWxsKHRvb2xDYWxsOiBhbnkpIHtcbiAgY29uc3QgeyBhZGRDaGF0TWVzc2FnZSB9ID0gdXNlQ29udmVyc2F0aW9uU3RvcmUuZ2V0U3RhdGUoKTtcbiAgXG4gIHRyeSB7XG4gICAgLy8gVXBkYXRlIHByb2dyZXNzIHRvIHNob3cgZXhlY3V0aW9uXG4gICAgYWRkQ2hhdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJ0b29sX2NhbGxfcHJvZ3Jlc3NcIixcbiAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgIG5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUsXG4gICAgICBzdGF0dXM6IFwiZXhlY3V0aW5nXCIsIFxuICAgICAgcHJvZ3Jlc3M6IDUwXG4gICAgfSk7XG5cbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lO1xuICAgIGNvbnN0IGZ1bmN0aW9uQXJncyA9IEpTT04ucGFyc2UodG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKTtcbiAgICBcbiAgICBpZiAoZnVuY3Rpb25zTWFwW2Z1bmN0aW9uTmFtZSBhcyBrZXlvZiB0eXBlb2YgZnVuY3Rpb25zTWFwXSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZnVuY3Rpb25zTWFwW2Z1bmN0aW9uTmFtZSBhcyBrZXlvZiB0eXBlb2YgZnVuY3Rpb25zTWFwXShmdW5jdGlvbkFyZ3MpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgcHJvZ3Jlc3MgdG8gc2hvdyBjb21wbGV0aW9uXG4gICAgICBhZGRDaGF0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwidG9vbF9jYWxsX3Byb2dyZXNzXCIsXG4gICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgbmFtZTogdG9vbENhbGwuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgc3RhdHVzOiBcImNvbXBsZXRlZFwiLFxuICAgICAgICBwcm9ncmVzczogMTAwLFxuICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZCB0b29sIHJlc3VsdCB0byBjb252ZXJzYXRpb25cbiAgICAgIGNvbnN0IHRvb2xSZXN1bHRNZXNzYWdlID0ge1xuICAgICAgICB0eXBlOiBcIm1lc3NhZ2VcIixcbiAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgIHRvb2xfY2FsbF9pZDogdG9vbENhbGwuaWQsXG4gICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidG9vbF9yZXN1bHRcIiwgcmVzdWx0OiBKU09OLnN0cmluZ2lmeShyZXN1bHQpIH1dXG4gICAgICB9O1xuICAgICAgXG4gICAgICB1c2VDb252ZXJzYXRpb25TdG9yZS5nZXRTdGF0ZSgpLmFkZENvbnZlcnNhdGlvbkl0ZW0odG9vbFJlc3VsdE1lc3NhZ2UpO1xuICAgICAgXG4gICAgICAvLyBDb250aW51ZSBjb252ZXJzYXRpb24gd2l0aCB0b29sIHJlc3VsdFxuICAgICAgYXdhaXQgcHJvY2Vzc1Rvb2xSZXN1bHQoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGV4ZWN1dGluZyBmdW5jdGlvbiBjYWxsOlwiLCBlcnJvcik7XG4gICAgYWRkQ2hhdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJ0b29sX2NhbGxfcHJvZ3Jlc3NcIixcbiAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgIG5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUsXG4gICAgICBzdGF0dXM6IFwiZXJyb3JcIixcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJcbiAgICB9KTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzVG9vbFJlc3VsdCgpIHtcbiAgY29uc3QgeyBjb252ZXJzYXRpb25JdGVtcywgc2V0QXNzaXN0YW50TG9hZGluZyB9ID0gdXNlQ29udmVyc2F0aW9uU3RvcmUuZ2V0U3RhdGUoKTtcbiAgXG4gIHNldEFzc2lzdGFudExvYWRpbmcodHJ1ZSk7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IHRvb2xzID0gYXdhaXQgZ2V0VG9vbHMoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiL2FwaS90dXJuX3Jlc3BvbnNlXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG1lc3NhZ2VzOiBjb252ZXJzYXRpb25JdGVtcyxcbiAgICAgICAgdG9vbHMsXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgYXdhaXQgaGFuZGxlVHVybihyZXNwb25zZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwcm9jZXNzaW5nIHRvb2wgcmVzdWx0OlwiLCBlcnJvcik7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0QXNzaXN0YW50TG9hZGluZyhmYWxzZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BHZW5lcmF0aW9uKCkge1xuICBpZiAoY29udHJvbGxlcikge1xuICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBjb250cm9sbGVyID0gbnVsbDtcbiAgICB1c2VDb252ZXJzYXRpb25TdG9yZS5nZXRTdGF0ZSgpLnNldEFzc2lzdGFudExvYWRpbmcoZmFsc2UpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiZnVuY3Rpb25zTWFwIiwidXNlQ29udmVyc2F0aW9uU3RvcmUiLCJnZXRUb29scyIsImNvbnRyb2xsZXIiLCJwcm9jZXNzTWVzc2FnZXMiLCJtZXNzYWdlIiwiYWRkQ2hhdE1lc3NhZ2UiLCJhZGRDb252ZXJzYXRpb25JdGVtIiwic2V0QXNzaXN0YW50TG9hZGluZyIsImNvbnZlcnNhdGlvbkl0ZW1zIiwiZ2V0U3RhdGUiLCJ1c2VyTWVzc2FnZSIsInR5cGUiLCJyb2xlIiwiY29udGVudCIsInRleHQiLCJ0b29scyIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJtZXNzYWdlcyIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJoYW5kbGVUdXJuIiwiZXJyb3IiLCJjb25zb2xlIiwiQWJvcnRDb250cm9sbGVyIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiY3VycmVudE1lc3NhZ2UiLCJjdXJyZW50VG9vbENhbGxzIiwiZG9uZSIsInZhbHVlIiwicmVhZCIsImNodW5rIiwiZGVjb2RlIiwibGluZXMiLCJzcGxpdCIsImZpbHRlciIsImxpbmUiLCJ0cmltIiwic3RhcnRzV2l0aCIsImV2ZW50RGF0YSIsInBhcnNlIiwic2xpY2UiLCJoYW5kbGVFdmVudCIsInJlbGVhc2VMb2NrIiwiZXZlbnQiLCJkYXRhIiwiaXRlbSIsInRleHRQYXJ0IiwicHVzaCIsImRlbHRhIiwibGVuZ3RoIiwibGFzdENvbnRlbnQiLCJjYWxsSWQiLCJpZCIsInRvb2xDYWxsIiwiZmluZCIsInRjIiwiZnVuY3Rpb24iLCJuYW1lIiwiYXJndW1lbnRzIiwicHJvZ3Jlc3MiLCJjb21wbGV0ZWRDYWxsIiwiZXhlY3V0ZUZ1bmN0aW9uQ2FsbCIsImZ1bmN0aW9uTmFtZSIsImZ1bmN0aW9uQXJncyIsInJlc3VsdCIsInRvb2xSZXN1bHRNZXNzYWdlIiwidG9vbF9jYWxsX2lkIiwicHJvY2Vzc1Rvb2xSZXN1bHQiLCJzdG9wR2VuZXJhdGlvbiIsImFib3J0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/assistant.ts\n"));

/***/ })

});